# Xray/X-ui SNI-based Routing Configuration
# SNI fallback routing for multiple services on single port 443

version: "1.1"
category: "xray-sni-routing"
last_updated: "2026-01-25"

# ⚠️ CRITICAL LIMITATION DISCOVERED ⚠️
# Xray Reality does NOT support multiple SNI fallbacks properly.
# The `realitySettings.target` field overrides the `fallbacks[]` array.
# See "known_limitations" below for details.
scope: "infrastructure"

pattern_name: "SNI Fallback Routing with Xray"
use_case: |
  Route multiple domains/subdomains to different backend services
  based on SNI (Server Name Indication) while sharing port 443

problem: |
  Need to host multiple services with different domains on a single
  server with only one public IP address. All services need to use
  port 443 (HTTPS), but each should route to different backends.

  Example:
  - redis.example.com → backend:8111 (Redis Backend)
  - llm.example.com → backend:8112 (LLM API Gateway)
  - Both need to terminate TLS at port 443

known_limitations: |
  ⚠️ **CRITICAL:** Xray Reality does NOT support multiple SNI fallbacks!

  Problem discovered 2026-01-25:
  - `realitySettings.target` acts as a SINGLE fallback destination
  - The `fallbacks[]` array is IGNORED when `realitySettings.target` is set
  - All non-VLESS traffic goes to the same `target` destination

  Evidence:
  ```json
  "streamSettings": {
    "fallbacks": [
      {"name": "redis.ayga.tech", "dest": "127.0.0.1:8443"},  // IGNORED
      {"name": "llm.ayga.tech", "dest": "127.0.0.1:8444"}     // IGNORED
    ],
    "realitySettings": {
      "target": "127.0.0.1:8443"  // This OVERRIDES fallbacks[]
    }
  }
  ```

  Workaround: Use port-based routing instead:
  - Service 1: https://redis.ayga.tech/ (port 443, xray default)
  - Service 2: https://llm.ayga.tech:9443/ (custom port, bypass xray)

  Alternative: Replace xray with nginx stream module + ssl_preread

solution:
  architecture: |
    Client → Xray (port 443) → SNI matching → Nginx (different ports) → Backends

    Xray uses SNI from TLS ClientHello to route to different nginx
    instances, which then proxy to the actual backend services.

  xray_fallbacks_config: |
    # In x-ui: Inbounds → Edit → Fallbacks section
    # Or in config.json under streamSettings:

    "fallbacks": [
      {
        "name": "llm.example.com",      # SNI to match
        "dest": "127.0.0.1:8444",       # Route to this nginx port
        "xver": 1,                      # Enable proxy protocol
        "alpn": "",
        "path": ""
      },
      {
        "name": "redis.example.com",
        "dest": "127.0.0.1:8443",
        "xver": 1,
        "alpn": "",
        "path": ""
      },
      {
        "name": "",                     # Empty = default/catch-all
        "dest": "127.0.0.1:8443",
        "xver": 1,
        "alpn": "",
        "path": ""
      }
    ]

  nginx_configs:
    - name: "llm.example.com on port 8444"
      config: |
        server {
            listen 127.0.0.1:8444 ssl proxy_protocol;
            http2 on;
            server_name llm.example.com;

            ssl_certificate /etc/letsencrypt/live/llm.example.com/fullchain.pem;
            ssl_certificate_key /etc/letsencrypt/live/llm.example.com/privkey.pem;

            set_real_ip_from 127.0.0.1;
            real_ip_header proxy_protocol;

            location / {
                proxy_pass http://backend:8112;
                # ... proxy settings
            }
        }

    - name: "redis.example.com on port 8443"
      config: |
        server {
            listen 127.0.0.1:8443 ssl proxy_protocol;
            http2 on;
            server_name redis.example.com;

            ssl_certificate /etc/letsencrypt/live/redis.example.com/fullchain.pem;
            ssl_certificate_key /etc/letsencrypt/live/redis.example.com/privkey.pem;

            set_real_ip_from 127.0.0.1;
            real_ip_header proxy_protocol;

            location / {
                proxy_pass http://backend:8111;
                # ... proxy settings
            }
        }

  xui_database_method: |
    # x-ui manages config.json and overwrites manual changes
    # Must update via SQLite database:

    # 1. Connect to database
    sqlite3 /etc/x-ui/x-ui.db

    # 2. View current stream_settings
    SELECT id, stream_settings FROM inbounds WHERE port = 443;

    # 3. Update fallbacks via Python script
    python3 << 'EOF'
    import sqlite3
    import json

    conn = sqlite3.connect('/etc/x-ui/x-ui.db')
    cursor = conn.cursor()

    cursor.execute('SELECT id, stream_settings FROM inbounds WHERE port = 443')
    row = cursor.fetchone()

    if row:
        inbound_id, stream_str = row
        stream = json.loads(stream_str)

        # Update fallbacks
        stream['fallbacks'] = [
            {'name': 'llm.example.com', 'dest': '127.0.0.1:8444', 'xver': 1},
            {'name': 'redis.example.com', 'dest': '127.0.0.1:8443', 'xver': 1},
            {'name': '', 'dest': '127.0.0.1:8443', 'xver': 1}
        ]

        new_stream = json.dumps(stream, separators=(',', ':'))
        cursor.execute('UPDATE inbounds SET stream_settings = ? WHERE id = ?',
                      (new_stream, inbound_id))
        conn.commit()

    conn.close()
    EOF

    # 4. Restart x-ui
    systemctl restart x-ui

  explanation: |
    How it works:
    1. Client connects to port 443 with SNI (llm.example.com)
    2. Xray reads SNI from TLS ClientHello
    3. Xray matches against fallbacks list by "name" field
    4. Connection forwarded to matched dest (127.0.0.1:8444)
    5. Nginx handles SSL and proxies to backend
    6. Proxy protocol passes real client IP

    Order matters! More specific SNI entries should come before
    the empty (default) entry.

benefits:
  - Single IP/port for multiple services
  - Real client IP via proxy_protocol
  - No need for multiple public IPs
  - Centralized TLS termination

drawbacks:
  - ⚠️ **DOES NOT WORK with Reality:** Multiple SNI fallbacks don't work
  - x-ui web panel has bugs with multiple fallback entries
  - Direct database editing breaks x-ui web interface
  - Complex configuration (xray + nginx) for single-use case
  - Harder debugging when routing fails

# WORKING SOLUTION: Port-Based Routing
working_solution:
  description: |
    Since Xray Reality doesn't support multiple SNI fallbacks, use
    port-based routing for additional services:

  setup: |
    # Primary service (through xray:443)
    redis.ayga.tech → xray:443 → nginx:8443 → backend:8111

    # Additional services (direct ports)
    llm.ayga.tech:9443 → nginx:9443 → backend:8112

  nginx_config_port_based: |
    # /etc/nginx/conf.d/llm-9443.conf
    server {
        listen 9443 ssl;  # Direct port, no proxy_protocol needed
        http2 on;
        server_name llm.ayga.tech;

        ssl_certificate /etc/letsencrypt/live/llm.ayga.tech/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/llm.ayga.tech/privkey.pem;

        location / {
            proxy_pass http://backend:8112;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_buffering off;  # For LLM streaming
            proxy_read_timeout 300s;
        }
    }

  firewall: |
    # Open custom port
    iptables -I INPUT -p tcp --dport 9443 -j ACCEPT

  benefits:
    - Simple, reliable configuration
    - Works with existing xray setup
    - No database hacking required
    - x-ui web interface stays functional

troubleshooting:
  - symptom: "All domains route to same backend"
    cause: "Fallbacks not in correct order, empty SNI matches first"
    solution: "Ensure specific SNI entries come before empty/default entry"

  - symptom: "x-ui web panel shows 500 error when adding fallback"
    cause: "x-ui bug with multiple fallback entries"
    solution: "Update via SQLite database directly, then restart x-ui"

  - symptom: "Changes disappear after x-ui restart"
    cause: "x-ui regenerates config.json from database"
    solution: "Always update database, never edit config.json directly"

  - symptom: "Client IP shows as 127.0.0.1"
    cause: "proxy_protocol not enabled or xver not set to 1"
    solution: "Set xver: 1 in fallback and 'proxy_protocol' in nginx listen"

alternative_approaches:
  - name: "Nginx stream module with ssl_preread"
    pros: ["Simpler config", "No x-ui dependency"]
    cons: ["Nginx must be on port 443", "Conflicts with xray"]

  - name: "HAProxy with SNI routing"
    pros: ["Built-in SNI routing", "Better performance"]
    cons: ["Another service to manage", "Steeper learning curve"]

  - name: "Separate IPs per service"
    pros: ["Simplest config", "Independent services"]
    cons: ["Need multiple public IPs", "Additional cost"]

tags: ["xray", "x-ui", "sni", "routing", "nginx", "reverse-proxy", "tls"]
