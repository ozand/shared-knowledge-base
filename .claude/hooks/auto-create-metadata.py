#!/usr/bin/env python3
"""
PostToolUse Hook: Auto-create _meta.yaml files for new KB entries
Generates metadata file alongside new YAML entries
"""

import sys
import json
import os
from datetime import datetime

def calculate_quality_score(file_path):
    """
    Calculate initial quality score based on content completeness
    Returns score 0-100
    """
    try:
        with open(file_path, 'r') as f:
            content = f.read()
    except:
        return 50  # Default score if can't read

    score = 50  # Base score

    # Problem description (+10)
    if 'problem:' in content and len(content.split('problem:')[1].split('symptoms:')[0]) > 50:
        score += 10

    # Root cause analysis (+10)
    if 'root_cause:' in content and len(content.split('root_cause:')[1].split('solution:')[0]) > 50:
        score += 10

    # Solution has code (+10)
    if 'code:' in content:
        score += 10

    # Solution has explanation (+10)
    if 'explanation:' in content:
        score += 10

    # Prevention tips (+10)
    if 'prevention:' in content:
        score += 10

    # Tags present (+5)
    if 'tags:' in content:
        score += 5

    # Multiple solutions or examples (+5)
    if content.count('###') > 2:
        score += 5

    # Real-world example (+5)
    if 'example' in content.lower():
        score += 5

    # Links to related (+5)
    if 'related:' in content.lower() or 'see also:' in content.lower():
        score += 5

    return min(score, 100)  # Max 100

def main():
    try:
        input_data = json.load(sys.stdin)
    except:
        sys.exit(0)

    file_path = input_data.get('tool_input', {}).get('file_path', '')

    # Only process YAML files (not _meta.yaml)
    if not (file_path.endswith('.yaml') or file_path.endswith('.yml')):
        sys.exit(0)

    if file_path.endswith('_meta.yaml'):
        sys.exit(0)

    # Check if _meta.yaml already exists
    meta_path = file_path.replace('.yaml', '_meta.yaml')
    if os.path.exists(meta_path):
        sys.exit(0)

    print(f"üìù Creating metadata: {meta_path}")

    # Calculate quality score
    quality_score = calculate_quality_score(file_path)

    # Get category from file
    category = "unknown"
    try:
        with open(file_path, 'r') as f:
            for line in f:
                if line.startswith('category:'):
                    category = line.split(':', 1)[1].strip().strip('"')
                    break
    except:
        pass

    # Create metadata content
    metadata_content = f"""# Metadata for {os.path.basename(file_path)}
# Auto-generated by Claude Code hooks

created_at: "{datetime.now().strftime('%Y-%m-%d')}"
last_analyzed_at: "{datetime.now().strftime('%Y-%m-%d')}"
quality_score: {quality_score}
validation_status: "pending"
tested_versions: []
next_version_check_due: "{datetime.now().strftime('%Y-%m-%d')}"

# Quality breakdown:
# Completeness (problem, root_cause, solution, prevention): 40 points
# Technical accuracy (working code, current info): 20 points
# Clarity (clear structure, explained examples): 20 points
# Discoverability (good ID, tags, summary): 20 points
# Actionability (step-by-step, copy-pasteable): 20 points

# Estimated quality: {quality_score}/100
"""

    # Write metadata file
    try:
        with open(meta_path, 'w') as f:
            f.write(metadata_content)

        print(f"  ‚úÖ Created {meta_path}")
        print(f"  üìä Initial quality score: {quality_score}/100")
        print(f"  üìå Status: pending (needs manual review)")
    except Exception as e:
        print(f"  ‚ùå Could not create metadata: {e}")
        sys.exit(0)  # Don't block on metadata creation failure

    sys.exit(0)

if __name__ == "__main__":
    main()
