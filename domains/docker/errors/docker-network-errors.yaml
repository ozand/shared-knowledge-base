version: "1.0"
title: Docker Network and Container Management Errors
scope: docker
severity: medium
category: docker-errors
last_updated: "2026-01-08"
tags:
  - docker
  - networking
  - containers
  - docker-compose
errors:
  - id: "DOCKER-023"
    title: "Container Name Conflicts on Recreation"
    severity: "medium"
    scope: docker
    problem: |
      Error when recreating containers: "Conflict. The container name '/xxx' is already in use"

      **Symptoms:**
      - `docker-compose up -d` fails with container name conflict
      - Old containers exist with same names
      - Containers are in "Exited" or "Restarting" state

      **Root Cause:**
      When containers fail or are stopped, `docker-compose` may leave them behind.
      When trying to recreate, Docker detects name conflicts with existing containers.

      **Common Scenarios:**
      - Container crashed and wasn't cleaned up
      - Previous `docker-compose up` attempt failed partway
      - Manually created containers with same names
      - Docker Compose version incompatibilities
    wrong_code: |
      # Attempting to recreate containers:
      $ docker-compose up -d
      Creating docker-api-1 ... error
      ERROR: for docker-api-1  Conflict. The container name "/docker-api-1" is already in use

      # Container exists in stopped/exited state:
      $ docker ps -a | grep docker-api-1
      68642cbff116   langgenius/dify-api:0.13.2   "command"   2 hours ago   Exited (1)   docker-api-1
    correct_code: |
      # 1. List containers with the target name:
      docker ps -a | grep container_name

      # 2. Stop and remove conflicting containers:
      docker stop container_name 2>/dev/null || true
      docker rm container_name 2>/dev/null || true

      # 3. Handle multiple conflicts:
      for container in container1 container2 container3; do
        docker stop $container 2>/dev/null || true
        docker rm $container 2>/dev/null || true
      done

      # 4. Now recreate with docker-compose:
      docker-compose up -d

      # 5. If docker-compose has issues, force recreate:
      docker-compose up -d --force-recreate

      # 6. Best practice - always clean up first:
      docker-compose down
      docker-compose up -d
    diagnosis_steps: |
      1. Find conflicting containers:
         ```bash
         docker ps -a --filter "name=target_name"
         ```

      2. Check container status:
         ```bash
         docker ps -a | grep "conflict_pattern"
         ```

      3. Inspect conflicting container:
         ```bash
         docker inspect conflicting_container --format '{{.State.Status}}'
         ```

      4. Remove all conflicts:
         ```bash
         docker ps -a --format "{{.Names}}" | grep "pattern" | xargs -I {} docker rm -f {}
         ```

      5. Clean Docker Compose state:
         ```bash
         cd /path/to/project
         docker-compose down --remove-orphans
         ```

      6. Verify no conflicts remain:
         ```bash
         docker ps -a | grep "container_name"
         # Should return empty
         ```
    related_entries:
      - DOCKER-PATTERN-002
      - DOCKER-020
    references: []

  - id: "DOCKER-024"
    title: "Inter-Container Communication Failure (Host vs Internal DNS)"
    severity: "high"
    scope: docker
    problem: |
      Containers in the same Docker network cannot communicate when using Host IP/Loopback.
      
      **Symptoms:**
      - "Connection refused" or "Connection reset by peer" when calling service A from B
      - `curl http://localhost:PORT` works on host, but fails from inside container
      - `curl http://HOST_IP:PORT` fails from inside container
      
      **Root Cause:**
      - **Loopback (localhost):** Inside a container, `localhost` refers to the container itself, not the host.
      - **Host IP:** Often blocked by firewall (iptables) or not routed correctly from inside Docker network loopback.
      - **Binding:** Target service might be bound to `127.0.0.1` inside its container, making it invisible to outside (even via port mapping).
      
      **Solution:**
      1. **Internal DNS:** Use the container name (e.g., `http://my-service:3000`) if both are in same network.
      2. **Bind 0.0.0.0:** Ensure target service listens on `0.0.0.0`, not `127.0.0.1`.
      3. **Host Gateway:** Use `host.docker.internal` (if configured) for host access.
    wrong_code: |
      # .env
      # Wrong: Trying to reach another container via Host IP or localhost
      SERVICE_URL=http://localhost:3000/v1
      SERVICE_URL=http://192.168.1.35:3000/v1
    correct_code: |
      # 1. Ensure both containers are in same network (docker-compose.yml)
      networks:
        my_network:
          external: true
          
      # 2. Use Container Name as Hostname
      SERVICE_URL=http://target-container-name:3000/v1
      
      # 3. Ensure target binds to all interfaces
      # target-service config:
      bind: 0.0.0.0
    diagnosis_steps: |
      1. Check networks:
         `docker inspect container_name` -> verify "Networks" matches target.
      2. Ping by name:
         `docker exec container_a ping container_b`
      3. Curl by name:
         `docker exec container_a curl -v http://container_b:port`
    related_entries: []
    references: []
