# Shared KB Update Process for Projects

version: "1.1"
category: "knowledge-base"
last_updated: "2026-01-06"

patterns:
  - id: "KB-UPDATE-001"
    title: "Shared KB Update Process for Projects"
    severity: "high"
    scope: "universal"
    tags: ["updates", "maintenance", "synchronization", "version-control"]

    problem: |
      Projects using Shared Knowledge Base need to stay current with
      new patterns and improvements. However, there's no systematic
      update mechanism, and agents don't know when their local KB is stale.

      **Key Issues:**
      - No version tracking
      - No update notifications
      - Manual git operations required
      - Agents unaware of new patterns
      - Knowledge gap grows over time

    impact: |
      - Projects work with outdated knowledge
      - Missing new patterns and improvements
      - Repeating solved problems
      - Inconsistent solutions across projects

    solution: |
      Implement systematic update process with automated checking
      and clear update workflows for different installation methods.

    workflows:
      git_submodule:
        description: "Update when Shared KB is installed as git submodule"

        check_for_updates:
          manual: |
            cd docs/knowledge-base/shared
            git fetch origin
            git log HEAD..origin/main --oneline

          automated: |
            python docs/knowledge-base/shared/tools/kb.py check-updates

          auto_check_on_bootstrap: |
            # Automatic check when agent session starts
            python tools/kb-agent-bootstrap.py

        update_command: |
          git submodule update --remote --merge docs/knowledge-base/shared

        what_happens: |
          1. Fetches latest changes from remote
          2. Merges changes into local submodule
          3. Resolves conflicts if needed
          4. Updates to latest commit

        rollback: |
          # If update breaks something
          cd docs/knowledge-base/shared
          git log --oneline -10  # Find previous commit
          git checkout <previous-commit-hash>
          cd ../..
          git add docs/knowledge-base/shared
          git commit -m "Rollback Shared KB to <commit-hash>"

      plain_clone:
        description: "Update when Shared KB is installed as plain git clone"

        check_for_updates:
          manual: |
            cd docs/knowledge-base/shared
            git fetch origin
            git log HEAD..origin/main --oneline

          automated: |
            python docs/knowledge-base/shared/tools/kb.py check-updates

          auto_check_on_bootstrap: |
            # Automatic check when agent session starts
            python tools/kb-agent-bootstrap.py

        update_command: |
          cd docs/knowledge-base/shared
          git pull origin main

        what_happens: |
          1. Fetches latest changes from remote
          2. Fast-forwards to latest commit
          3. Updates working directory
          4. Reports conflicts if any

        resolve_conflicts: |
          # If there are conflicts (rare in plain clone)
          cd docs/knowledge-base/shared
          git status  # See conflicted files
          # Edit conflicted files
          git add <resolved-files>
          git commit  # Complete merge

        rollback: |
          # If update breaks something
          cd docs/knowledge-base/shared
          git reflog  # Find previous position
          git reset --hard HEAD@{N}  # Where N is the reflog entry
          # Or:
          git checkout <previous-commit-hash>

      sparse_checkout:
        description: "Update with sparse checkout (excludes Curator files)"

        check_for_updates:
          automated: |
            python docs/knowledge-base/shared/tools/kb.py check-updates

        update_command: |
          # Same as submodule or clone
          git submodule update --remote --merge docs/knowledge-base/shared
          # OR
          cd docs/knowledge-base/shared && git pull origin main

        verify_sparse_active: |
          # Ensure sparse checkout still active after update
          cd docs/knowledge-base/shared
          git config core.sparseCheckout  # Should return "true"
          ls .git/info/sparse-checkout  # Should exist

        if_broken: |
          # If update loads all files (sparse checkout broken)
          cd docs/knowledge-base/shared
          git config core.sparseCheckout true
          cat > .git/info/sparse-checkout < sparse-checkout.example
          git reset --hard HEAD
          git checkout

    recommended_frequency:
      active_development: |
        - Weekly during active development
        - Before starting major work
        - Before using critical patterns
        - When encountering unfamiliar errors

      maintenance_mode: |
        - Monthly for maintenance projects
        - Before releasing new versions
        - When responding to support requests

      always_update_before: |
        - Using critical security patterns
        - Implementing complex workflows
        - Troubleshooting difficult issues
        - Onboarding new team members

    troubleshooting:
      issue_1_network_error:
        symptom: "Could not fetch from remote"
        causes:
          - "No internet connection"
          - "GitHub repository inaccessible"
          - "Firewall blocking git requests"
          - "SSH key authentication issues (if using SSH)"

        solutions:
          - solution: "Check internet connection"
            command: "ping github.com"

          - solution: "Switch from SSH to HTTPS"
            command: |
              # In .gitmodules
              url = https://github.com/ozand/shared-knowledge-base.git

          - solution: "Use VPN or proxy if needed"

          - solution: "Configure git proxy"
            command: |
              git config --global http.proxy http://proxy.example.com:8080

      issue_2_merge_conflict:
        symptom: "Automatic merge failed; fix conflicts"
        causes:
          - "Local changes in Shared KB directory"
          - "Diverged history"
          - "Both submodule and local modified same files"

        solutions:
          - solution: "Stash local changes first"
            command: |
              cd docs/knowledge-base/shared
              git stash
              git submodule update --remote --merge
              # Apply stash back if needed
              git stash pop

          - solution: "Reset to clean state"
            command: |
              cd docs/knowledge-base/shared
              git reset --hard origin/main
              cd ../..
              git add docs/knowledge-base/shared
              git commit -m "Reset Shared KB to clean state"

          - solution: "Resolve conflicts manually"
            steps:
              - "cd docs/knowledge-base/shared"
              - "git status  # See conflicts"
              - "Edit conflicted files, remove markers"
              - "git add <resolved-files>"
              - "git commit"

      issue_3_submodule_detached:
        symptom: "Submodule in detached HEAD state"
        causes:
          - "Manual git operations in submodule"
          - "Incomplete update"
          - "Checkout to specific commit"

        solutions:
          - solution: "Reattach to main branch"
            command: |
              cd docs/knowledge-base/shared
              git checkout main
              git pull origin main
              cd ../..
              git add docs/knowledge-base/shared
              git commit -m "Reattach Shared KB to main"

          - solution: "Use submodule update"
            command: |
              git submodule update --remote --merge docs/knowledge-base/shared

      issue_4_sparse_checkout_broken:
        symptom: "All files loaded, including curator/"
        causes:
          - "Sparse checkout config lost"
          - ".git/info/sparse-checkout deleted"
          - "core.sparseCheckout reset to false"

        solutions:
          - solution: "Re-enable sparse checkout"
            command: |
              cd docs/knowledge-base/shared
              git config core.sparseCheckout true
              cat > .git/info/sparse-checkout <<'EOF'
              universal/
              python/
              postgresql/
              docker/
              javascript/
              vps/
              tools/
              scripts/
              README.md
              GUIDE.md
              AGENT_*.md
              ROLE_SEPARATION_GUIDE.md
              GITHUB_ATTRIBUTION_GUIDE.md
              .kb-config.yaml
              .gitignore.agents
              EOF
              git reset --hard HEAD
              git checkout

          - solution: "Use automated script"
            command: |
              bash /path/to/shared-knowledge-base/scripts/setup-shared-kb-sparse.sh

      issue_5_feature_branch_not_merged:
        symptom: "Feature branch exists but submodule update doesn't merge it"
        example: |
          git submodule update --remote --merge docs/knowledge-base/shared
          # Output: * [new branch] fix/feature -> origin/fix/feature
          # But no merge happens!

        causes:
          - "Feature branch not merged to main in upstream repository"
          - "Submodule tracks 'main', not feature branches"
          - "git submodule update --remote only updates tracked branch"

        explanation: |
          git submodule update --remote updates to the **tracked branch**
          (usually origin/main), NOT to any feature branches.

          Feature branches must be merged to main in upstream repository
          BEFORE projects can get them via standard submodule update.

        solutions:
          - solution: "Verify content already in main (COMMON CASE)"
            command: |
              cd docs/knowledge-base/shared
              # Check if file/feature already exists
              ls -la tools/kb_config.py

              # If exists: Feature already merged to main
              # If missing: Feature not yet in main

            when_to_use: "Feature branch was created before similar changes merged to main"

          - solution: "Wait for upstream merge (RECOMMENDED)"
            steps:
              - "Check upstream repository status"
              - "Wait for feature branch to be merged to main"
              - "Then run: git submodule update --remote --merge"
              - "Usually takes 1-7 days"

            rationale: "Standard workflow, maintains alignment with upstream"

          - solution: "Request expedited merge"
            steps:
              - "Comment on upstream PR/issue"
              - "Explain urgency: 'Need this feature for production'"
              - "Wait for merge, then update"

            when_to_use: "Feature is critical for your project"

          - solution: "Manually merge feature branch (NOT RECOMMENDED)"
            command: |
              cd docs/knowledge-base/shared
              git fetch origin
              git merge origin/fix/feature-branch
              cd ../..
              git add docs/knowledge-base/shared
              git commit -m "Update Shared KB to feature branch"

            warnings:
              - "⚠️ Creates divergence from main"
              - "⚠️ May cause conflicts later"
              - "⚠️ Non-standard workflow"
              - "⚠️ Use only if absolutely necessary"

        decision_framework:
          question: "Should you merge feature branch manually?"

          check_main_first:
            action: "Verify if content already in main"
            command: |
              git fetch origin
              git log origin/main --oneline | grep feature-description

            if_in_main: |
              ✅ Stay on main, don't merge feature branch
              Standard update will get the changes

            if_not_in_main: |
              ⏰ Wait for upstream merge OR request expedited merge

          evaluate_urgency:
            question: "Is this feature critical for your project?"

            if_yes: |
              1. Comment on upstream PR/issue requesting expedited merge
              2. Explain business impact
              3. Wait for merge (usually faster with maintainer context)

            if_no: |
              1. Wait for standard merge process
              2. Usually 1-7 days
              3. Then: git submodule update --remote --merge

        real_world_example:
          project: "CompanyBase"
          situation: |
            git submodule update --remote --merge docs/knowledge-base/shared
            # Shows: * [new branch] fix/add-kb-config-v5.1
            # But: No merge, submodule stays on main

          analysis: |
            Feature branch fix/add-kb-config-v5.1 adds kb_config.py
            BUT: Main already has commit 347ecea that adds kb_config.py

          root_cause: |
            Feature branch created before commit was merged to main
            Content is duplicate/old version

          solution_applied: |
            1. Verified: tools/kb_config.py already exists in main
            2. Stayed on main branch
            3. No need to merge feature branch

          result: |
            ✅ v5.1 features working via main branch
            ✅ No divergence from upstream
            ✅ Standard update workflow maintained

      issue_6_plain_clone_not_git_repo:
        symptom: "git submodule commands fail - 'not a git repository'"
        example: |
          git submodule update --remote --merge docs/knowledge-base/shared
          fatal: not a git repository (or any of the parent directories)

        causes:
          - "Project not initialized as git repository"
          - "Shared KB installed as plain clone, not submodule"
          - "No .git directory in project root"

        explanation: |
          Project uses plain clone installation method:
          - Shared KB added via: git clone https://github.com/...
          - Not via: git submodule add
          - Project root has no .git directory

          Result:
          - git submodule commands don't work from project root
          - But shared/ directory IS a git repository
          - Can update shared/ directly with git commands

        solutions:
          - solution: "Update shared/ directly (WORKAROUND)"
            command: |
              cd docs/knowledge-base/shared
              git pull origin main

            when_to_use: "Short-term, before git init"
            pros:
              - "Works immediately"
              - "No setup required"
            cons:
              - "Manual process"
              - "Must remember to update"
              - "No submodule benefits"

          - solution: "Initialize git and migrate to submodule (RECOMMENDED)"
            steps: |
              # 1. Initialize git for project
              cd /path/to/project
              git init

              # 2. Create .gitignore
              # (Exclude: venv, __pycache__, .idea, etc.)

              # 3. Initial commit
              git add .
              git commit -m "Initial commit"

              # 4. Remove old clone
              rm -rf docs/knowledge-base/shared

              # 5. Add as submodule (optionally with sparse checkout)
              git submodule add https://github.com/ozand/shared-knowledge-base.git \
                docs/knowledge-base/shared

              # OR use automated sparse setup
              bash /path/to/shared-knowledge-base/scripts/setup-shared-kb-sparse.sh

              # 6. Test
              git submodule update --remote --merge docs/knowledge-base/shared

            when_to_use: "When ready for professional setup"
            pros:
              - "git submodule update works"
              - "Version pinning available"
              - "Team collaboration enabled"
              - "Can use sparse checkout"
              - "Automatic update checks"
            cons:
              - "One-time setup required"
              - "Takes ~5 minutes"

          - solution: "Use sparse checkout during migration (OPTIMAL)"
            steps: |
              # Use automated script with sparse checkout
              bash /path/to/shared-knowledge-base/scripts/setup-shared-kb-sparse.sh

            benefits:
              - "Loads only patterns + agent guides"
              - "Excludes Curator files (~22% savings)"
              - "Clean context for Project Agents"
              - "Role separation enforced"

        real_world_example:
          project: "PARSER"
          situation: |
            git submodule update --remote --merge docs/knowledge-base/shared
            fatal: not a git repository

            cd docs/knowledge-base/shared
            git status
            # On branch main
            # Your branch is up to date with 'origin/main'

          analysis: |
            PARSER project:
            - Not under git (no .git in root)
            - Shared KB installed as plain clone
            - But shared/ IS a git repository

            Verification:
            ls docs/knowledge-base/shared/.git
            # Exists! It's a git repository

          current_solution: |
            # Update shared/ directly
            cd docs/knowledge-base/shared
            git pull origin main
            # Already up to date

          recommended_migration: |
            1. Initialize git: cd /path/to/PARSER && git init
            2. Initial commit: git add . && git commit -m "Initial"
            3. Migrate to submodule: Remove old clone, add as submodule
            4. Setup sparse checkout: Exclude Curator files
            5. Test: git submodule update --remote --merge

          benefits_of_migration:
            - "✅ Standard submodule commands work"
            - "✅ Clean context (sparse checkout)"
            - "✅ Easy updates"
            - "✅ Team collaboration"
            - "✅ Automatic update checks"

          timeline: |
            Phase 1 (Current): Continue with plain clone
            Phase 2 (When ready): Initialize git
            Phase 3 (Migration): Add submodule + sparse checkout
            Phase 4 (Long-term): Enable auto-update checks

        decision_framework:
          question: "Should project initialize git?"

          checklist:
            - question: "Is code stable?"
              if_yes: "✅ Ready for git init"
              if_no: "⏰ Wait until stable"

            - question: "Will others work on it?"
              if_yes: "✅ Git init recommended"
              if_no: "❌ Local is fine"

            - question: "Need collaboration?"
              if_yes: "✅ Git required"
              if_no: "❌ Local OK"

            - question: "Want automatic updates?"
              if_yes: "✅ Submodule helps"
              if_no: "⚠️ Manual update OK"

          recommendation: |
            3+ YES answers: Initialize git ✅
            1-2 YES answers: Can continue plain clone ⏰

        see_also:
          - "PLAIN_CLONE_PROJECT_ANALYSIS.md - Detailed PARSER analysis"
          - "SUBMODULE_VS_CLONE.md - Comparison of approaches"
          - "scripts/setup-shared-kb-sparse.sh - Automated setup"
          - "SHARED_KB_UPDATE_MECHANISMS_ANALYSIS.md - Update mechanisms"

    best_practices:
      practice_1_automate_checks: |
        **Always enable automatic update checks on bootstrap**

        Rationale: Agents are automatically notified when updates are available,
        reducing the chance of working with stale knowledge.

        Implementation:
        - Ensure AGENT-AUTO-001 bootstrap is configured
        - Run `python tools/kb-agent-bootstrap.py` on session start
        - Or integrate into project's agent startup script

      practice_2_update_before_major_work: |
        **Update Shared KB before starting major work**

        Rationale: Ensures you have access to the latest patterns and solutions,
        especially for critical tasks.

        Examples:
        - Before implementing authentication system
        - Before troubleshooting complex database issues
        - Before performance optimization work
        - Before onboarding new developers

      practice_3_document_local_changes: |
        **Never modify Shared KB files directly**

        Rationale: Local modifications create merge conflicts and prevent updates.

        Instead:
        - Add project-specific patterns to project's local KB
        - Use tags: local_only: true
        - Contribute universal patterns via GitHub Issues

      practice_4_test_after_update: |
        **Test critical patterns after update**

        Rationale: New versions may have changes that affect existing workflows.

        Checklist:
        - Verify key patterns still work
        - Check for deprecated patterns
        - Review new patterns added
        - Update project documentation if needed

      practice_5_rollback_plan: |
        **Know how to rollback before updating**

        Rationale: If update breaks something, you need quick recovery.

        Preparation:
        - Commit project state before updating Shared KB
        - Know rollback commands for your setup (submodule vs clone)
        - Test rollback process in non-critical environment

      practice_6_update_frequency: |
        **Match update frequency to project activity**

        Guidelines:
        - Active projects: Weekly or before major work
        - Maintenance projects: Monthly
        - Critical systems: Before any deployment
        - Learning/onboarding: Always use latest

    anti_patterns:
      anti_pattern_1_ignore_updates:
        wrong: "Never updating Shared KB"
        consequences:
          - "Missing new patterns and improvements"
          - "Working with outdated solutions"
          - "Repeating solved problems"
          - "Knowledge gap grows over time"

        correct: "Regular updates following recommended frequency"

      anti_pattern_2_local_modifications:
        wrong: "Modifying Shared KB files directly"
        consequences:
          - "Merge conflicts on every update"
          - "Changes lost on update"
          - "Cannot update cleanly"
          - "Violates Shared KB principles"

        correct: "Use project-local KB for project-specific patterns"

      anti_pattern_3_blind_update:
        wrong: "Updating without reviewing changes"
        consequences:
          - "Surprise breaking changes"
          - "Missed migration requirements"
          - "New patterns not discovered"

        correct: "Check what changed, then update"
        steps:
          - "Run: python tools/kb.py check-updates"
          - "Review commit summaries"
          - "Plan for any breaking changes"
          - "Then update"

      anti_pattern_4_update_in_production:
        wrong: "Updating Shared KB during critical production work"
        consequences:
          - "Unexpected behavior changes"
          - "Production downtime risk"
          - "Rollback complexity"

        correct: "Update in development/staging first, test, then production"

    success_examples:
      example_1_standard_update_verification:
        project: "CompanyBase"
        scenario: "Regular update check - already up to date"
        date: "2026-01-06"

        what_was_done:
          - step: "Ran: git submodule update --remote --merge"
            result: "No output (no updates available)"

          - step: "Verified current commit"
            result: "c023036 - Fix all 5 YAML errors (today)"

          - step: "Checked remote for new commits"
            result: "None - already at latest"

          - step: "Verified content"
            result: "62 YAML + 24 MD files present"

          - step: "Rebuilt index"
            result: "95 entries indexed successfully"

          - step: "Confirmed clean state"
            result: "Working tree clean, no changes"

        outcome: |
          ✅ Perfect verification workflow
          ✅ Submodule correctly configured
          ✅ All systems functional
          ✅ No action needed (already latest)

        lessons_learned:
          - "No output from update command = SUCCESS (already up to date)"
          - "Multiple verification methods provide confidence"
          - "Regular checks maintain system health"
          - "Indexing after update ensures searchability"

        best_practices_demonstrated:
          - practice: "Regular update schedule"
            evidence: "Running update verification (daily/weekly)"

          - practice: "Comprehensive verification"
            evidence: "7 different verification methods used"

          - practice: "Testing after check"
            evidence: "Rebuilt index to ensure functionality"

          - practice: "Status documentation"
            evidence: "Clear status report with all details"

        key_takeaway: |
          This is the EXPECTED and PERFECT scenario:
          - Update command runs cleanly
          - No conflicts or errors
          - System verifies all components
          - Clear status documented
          - No action required

      example_2_feature_branch_handling:
        project: "CompanyBase"
        scenario: "Feature branch discovered but not merged"
        date: "2026-01-06"

        what_happened:
          - event: "Ran: git submodule update --remote --merge"
            output: "* [new branch] fix/add-kb-config-v5.1"

          - event: "Expected: Merge feature branch"
            actual: "No merge - submodule stayed on main"

          - event: "Investigation"
            finding: "Main already has kb_config.py (commit 347ecea)"

          - event: "Analysis"
            conclusion: "Feature branch is old/duplicate"

          - event: "Decision"
            action: "Stay on main, don't merge feature branch"

        outcome: |
          ✅ Correct analysis prevented divergence
          ✅ Standard workflow maintained
          ✅ No merge conflicts later
          ✅ Already have needed functionality

        lessons_learned:
          - "Feature branches must be merged to main first"
          - "Check if content already in main before merging features"
          - "git submodule update --remote only tracks main"
          - "Non-standard workflows create technical debt"

        see_also:
          - "SUBMODULE_UPDATE_FEATURE_BRANCH_ANALYSIS.md - Full analysis"
          - "KB-UPDATE-001 issue_5 - Feature branch troubleshooting"

      example_3_migration_v2_to_v3:
        project: "VPS Knowledge Base (personal project)"
        scenario: "Migration from plain clone v2.0 to git submodule v5.1"
        date: "2026-01-06"

        before_migration:
          location: "/home/ozand/knowledge-base"
          version: "v2.0.0-13-g5ec545a"
          installation: "Plain git clone"
          structure: "Mixed shared + VPS-specific content"
          problems:
            - "Shared and VPS content mixed together"
            - "Manual updates required (file copying)"
            - "Doesn't follow v5.1 best practices"
            - "No clear separation of concerns"

        migration_steps:
          - step: "Backup old version"
            command: "mv /home/ozand/knowledge-base /home/ozand/knowledge-base-v2-backup"
            result: "Safe backup created"

          - step: "Create new v5.1 structure"
            command: |
              mkdir -p /home/ozand/vps-knowledge/docs/knowledge-base/{project/{errors,patterns},tools}
              cd /home/ozand/vps-knowledge && git init
            result: "New structure with git initialized"

          - step: "Add Shared KB as submodule"
            command: |
              git submodule add git@github.com:ozand/shared-knowledge-base.git \
                docs/knowledge-base/shared
            result: "Latest v5.1 obtained (v5.1-10-gc023036)"

          - step: "Migrate VPS-specific content"
            command: |
              cp -r /home/ozand/knowledge-base-v2-backup/vps/* \
                docs/knowledge-base/project/
            result: "27 VPS YAML files migrated"

          - step: "Setup tools and configuration"
            command: |
              cp docs/knowledge-base/shared/tools/kb.py docs/knowledge-base/tools/
              mkdir -p docs/knowledge-base/.cache
            result: "Tools ready, .kb-config.yaml created"

          - step: "Build index and verify"
            command: "python3 docs/knowledge-base/tools/kb.py index -v"
            result: "47 entries indexed (19 VPS + 28 shared)"

          - step: "Maintain backward compatibility"
            command: |
              ln -sf /home/ozand/vps-knowledge /home/ozand/knowledge-base
            result: "Old path still works via symlink"

          - step: "Update integration scripts"
            files_updated:
              - "~/.claude/skills/vps-admin.sh (path updates)"
              - "~/.claude/scripts/kb-weekly-index-v3.sh (new script)"
            result: "All commands work with new paths"

          - step: "Create documentation"
            files_created:
              - "README.md (usage guide)"
              - "MIGRATION_V3.md (detailed migration doc)"
              - "update-shared-kb.sh (automation script)"
            result: "Comprehensive documentation"

          - step: "Commit to git"
            command: "git add . && git commit -m 'Initial VPS KB setup with Shared KB v5.1'"
            result: "18 files committed, clean state"

        after_migration:
          location: "/home/ozand/vps-knowledge"
          version: "v5.1-10-gc023036"
          installation: "Git submodule"
          structure: |
            docs/knowledge-base/
            ├── shared/    → Submodule (community maintained)
            └── project/   → VPS-specific (locally maintained)

        statistics_comparison:
          before: "v2.0.0-13-g5ec545a | 55 entries (with duplicates) | Plain clone"
          after: "v5.1-10-gc023036 | 47 entries (unique) | Git submodule"
          time_investment: "~15 minutes"
          downtime: "None (seamless migration)"

        verification_tests:
          - test: "Index building"
            command: "python3 docs/knowledge-base/tools/kb.py index -v"
            result: "✅ 47 entries indexed"

          - test: "Statistics"
            command: "vps-admin kb-stats"
            result: "✅ 19 VPS + 28 shared entries"

          - test: "Search - VPS patterns"
            command: "vps-admin kb-search 'vps'"
            result: "✅ 16 results found"

          - test: "Search - Specific issue"
            command: "vps-admin kb-search 'port conflict'"
            result: "✅ 2 results found"

          - test: "Update command"
            command: "./update-shared-kb.sh"
            result: "✅ Automated update works"

        outcome: |
          ✅ Successfully migrated from v2.0 plain clone to v5.1 submodule
          ✅ Clean separation: shared/ vs project/
          ✅ Easy updates: git submodule update --remote
          ✅ All functionality preserved
          ✅ Zero downtime (symlink compatibility)
          ✅ Comprehensive documentation
          ✅ Automated updates enabled

        lessons_learned:
          - "Migration is straightforward (~15 minutes)"
          - "Backup first prevents data loss"
          - "Clean structure eliminates confusion"
          - "Submodule simplifies updates significantly"
          - "Backward compatibility reduces friction"
          - "Documentation and automation are essential"
          - "Multiple verification methods ensure confidence"

        best_practices_demonstrated:
          - practice: "Backup before migration"
            evidence: "Old directory preserved as knowledge-base-v2-backup"

          - practice: "Clean structure separation"
            evidence: "shared/ (community) vs project/ (VPS-specific)"

          - practice: "Git submodule usage"
            evidence: "Standard update mechanism with version tracking"

          - practice: "Comprehensive testing"
            evidence: "5 different verification tests performed"

          - practice: "Backward compatibility"
            evidence: "Symlink maintains old path functionality"

          - practice: "Documentation"
            evidence: "3 documentation files created (README, MIGRATION_V3, script)"

          - practice: "Automation"
            evidence: "Update script + weekly index script + cron template"

        key_benefits:
          benefit_1_updates:
            before: "Manual file copying from upstream"
            after: "git submodule update --remote (one command)"

          benefit_2_structure:
            before: "Mixed content, unclear ownership"
            after: "Clear separation: shared (read-only) vs project (editable)"

          benefit_3_version_tracking:
            before: "Manual version tracking (git describe)"
            after: "Automatic via git submodule (git status)"

          benefit_4_community:
            before: "Isolated, manual updates"
            after: "Receives community improvements automatically"

        update_workflow_v3:
          manual: |
            cd /home/ozand/vps-knowledge
            git submodule update --remote docs/knowledge-base/shared
            vps-admin kb-index

          automated: |
            ./update-shared-kb.sh

          what_gets_updated:
            shared_kb: "All community patterns, bug fixes, features"
            project_kb: "NOT affected - safe to edit"

        next_steps_optional:
          - option: "Enable sparse checkout (v5.1)"
            benefit: "Exclude Curator files, save ~22% space"
            command: "See SUBMODULE_CONTEXT_CONTAMINATION_ANALYSIS.md"

          - option: "Add auto-update check (v5.1)"
            benefit: "Automatic notification of updates"
            command: "python3 docs/knowledge-base/shared/tools/kb-agent-bootstrap.py"

          - option: "Setup cron job"
            benefit: "Weekly automatic index rebuild"
            command: "sudo cp /tmp/kb-weekly-v3.cron /etc/cron.d/kb-weekly-index"

        see_also:
          - "VPS_MIGRATION_V2_TO_V3_ANALYSIS.md - Complete migration analysis"
          - "README_INTEGRATION.md - Integration guide for new projects"
          - "SUBMODULE_VS_CLONE.md - Comparison of installation methods"

    agent_commands: |
      ⚠️ **FOR AI AGENTS UPDATING SHARED KB:**

      When updating Shared Knowledge Base, AI agents MUST follow this workflow:

      **CRITICAL RULES:**
      1. ✅ Always use `git submodule` commands (NEVER direct access)
      2. ✅ Verify state before referencing (check issues/PRs first)
      3. ✅ Interpret status output correctly
      4. ❌ Never use `git -C` or `cd` into submodule

      **Complete Agent Workflow:**

      ```bash
      # Step 1: Check submodule status (ALWAYS FIRST)
      git submodule status docs/knowledge-base/shared
      # Output:  c023036 docs/knowledge-base/shared (v5.1-10-gc023036)
      #          ^ Leading space = properly initialized ✅

      # Step 2: Verify before referencing resources
      # Example: Check if Issue #11 is still open
      gh issue view 11 --json state,title
      # If CLOSED: Don't reference it (STALE-CONTEXT-001)

      # Step 3: Update submodule
      git submodule update --remote docs/knowledge-base/shared
      # No output = already up to date (this is GOOD!)
      # Output with commits = update applied

      # Step 4: Verify update succeeded
      git submodule status docs/knowledge-base/shared
      # Compare commit hash: if different = updated, if same = was already latest

      # Step 5: Use KB tools
      python3 docs/knowledge-base/shared/tools/kb.py stats
      ```

      **Verification Checklist:**
      - [ ] First command: `git submodule status` (not `git -C` or `cd`)
      - [ ] Verified issue/PR state before referencing
      - [ ] Interpreted status symbols correctly (space=good, -=bad, +=warning)
      - [ ] Working from project root (not inside submodule)
      - [ ] Used relative paths (not absolute)

      **Forbidden Patterns (NEVER do these):**
      ```bash
      # ❌ WRONG - Direct access
      git -C docs/knowledge-base/shared fetch origin
      cd docs/knowledge-base/shared && git pull

      # ❌ WRONG - Not verifying first
      echo "Waiting for Issue #11"  # Issue might be closed!

      # ❌ WRONG - Assuming state
      gh pr view 12  # Might be merged or closed
      ```

      **Required Patterns (ALWAYS do these):**
      ```bash
      # ✅ CORRECT - Submodule commands
      git submodule status docs/knowledge-base/shared
      git submodule update --remote docs/knowledge-base/shared

      # ✅ CORRECT - Verify first
      ISSUE_STATE=$(gh issue view 11 --json state --jq '.state')
      [ "$ISSUE_STATE" = "OPEN" ] && echo "Issue #11 open" || echo "Issue #11 closed"

      # ✅ CORRECT - Check actual state
      gh pr view 12 --json state,merged
      ```

      **Interpreting Status Output:**
      See SUBMODULE-STATUS-INTERPRETATION-001 for complete reference:
      - ` c023036` (leading space) = ✅ Properly initialized
      - `-c023036` (minus sign) = ❌ Not initialized
      - `+c023036` (plus sign) = ⚠️ Uncommitted changes
      - `-U c023036` (U suffix) = ❌ Merge conflict

      **What "No output" Means:**
      ```bash
      git submodule update --remote docs/knowledge-base/shared
      # No output = Already up to date ✅ (This is GOOD!)
      ```

      **Real-World Examples:**

      **Example 1: Correct workflow**
      ```bash
      # User asks: "обнови статус Share KB используя git submodule commands"

      # Agent responds:
      git submodule status docs/knowledge-base/shared
      # Output:  c023036 docs/knowledge-base/shared (v5.1-10-gc023036)

      git submodule update --remote docs/knowledge-base/shared
      # No output (already up to date)

      git submodule status docs/knowledge-base/shared
      # Output:  c023036 docs/knowledge-base/shared (v5.1-10-gc023036)
      # Same commit = confirmed already was at latest

      python3 docs/knowledge-base/shared/tools/kb.py stats
      # Output: Shared KB v5.1-10-gc023036, 95 entries indexed
      ```

      **Example 2: Stale context prevented**
      ```bash
      # Agent wants to reference Issue #11

      # CORRECT - Verify first
      gh issue view 11 --json state,title
      # Output: state: "closed", title: "..."

      # Result: Don't reference Issue #11, it's closed
      # Prevented: "Waiting for Issue #11" mistake
      ```

      **Example 3: Status interpretation**
      ```bash
      git submodule status docs/knowledge-base/shared
      # Output:  c023036 docs/knowledge-base/shared (v5.1-10-gc023036)

      # Agent interpretation:
      # - Leading space = properly initialized ✅
      # - c023036 = current commit hash
      # - v5.1-10-gc023036 = 10 commits ahead of v5.1 tag (effectively v5.1)
      # - No + symbol = no uncommitted changes ✅
      # - Status: Healthy, ready for update
      ```

      **Related Patterns:**
      - AGENT-DIRECT-SUBMODULE-ACCESS-001 (Why direct access is forbidden)
      - SUBMODULE-STATUS-INTERPRETATION-001 (Understanding status symbols)
      - STALE-CONTEXT-001 (Verify before referencing)
      - AGENT-QUICK-START.md (Complete agent quick reference)

    integration_points:
      point_1_automation: |
        **Auto-Check on Bootstrap (AGENT-AUTO-001)**

        Update checking is integrated into agent bootstrap:
        - Automatically runs on session start
        - Non-blocking (doesn't fail if network unavailable)
        - Shows clear update notifications
        - Provides update commands

        Script: tools/kb-agent-bootstrap.py
        Function: check_kb_updates()

      point_2_command_line: |
        **Manual Check Command**

        Check for updates anytime:
        ```bash
        python tools/kb.py check-updates
        ```

        Features:
        - Detects submodule vs clone
        - Shows recent commits
        - Provides update command
        - Shows recommended frequency

      point_3_ci_cd: |
        **CI/CD Integration**

        Check for updates in CI/CD pipeline:
        ```yaml
        # Example GitHub Actions
        - name: Check Shared KB Updates
          run: |
            python docs/knowledge-base/shared/tools/kb.py check-updates
        ```

        Use cases:
        - Warn about outdated KB in builds
        - Suggest updates before deployment
        - Track update compliance

    related_patterns:
      - id: "AGENT-AUTO-001"
        title: "Agent Auto-Configuration from Shared KB"
        relationship: "integrates"
        explanation: |
          KB-UPDATE-001's automated check is integrated into AGENT-AUTO-001
          bootstrap process, ensuring agents are notified on session start.

      - id: "SHARED-KB-SETUP-001"
        title: "Shared KB Sparse Checkout Setup"
        relationship: "complementary"
        explanation: |
          SHARED-KB-SETUP-001 configures sparse checkout to exclude Curator
          files. KB-UPDATE-001 shows how to update while maintaining sparse checkout.

      - id: "KB-INDEX-001"
        title: "Supporting Multiple Entry Keys"
        relationship: "related"
        explanation: |
          KB-INDEX-001 ensures both 'errors' and 'patterns' keys are indexed.
          Updates to KB indexing are handled via KB-UPDATE-001 workflow.

    references:
      - title: "SHARED_KB_UPDATE_MECHANISMS_ANALYSIS.md"
        description: "Detailed analysis of update mechanisms and gaps"

      - title: "SUBMODULE_VS_CLONE.md"
        description: "Comparison of submodule vs clone approaches"

      - title: "SUBMODULE_CONTEXT_CONTAMINATION_ANALYSIS.md"
        description: "Sparse checkout implementation to exclude Curator files"

      - title: "VPS_MIGRATION_V2_TO_V3_ANALYSIS.md"
        description: "Complete analysis of successful v2.0 to v5.1 migration"

      - title: "tools/kb.py check-updates"
        description: "Command-line tool to check for updates"

      - title: "tools/kb-agent-bootstrap.py"
        description: "Bootstrap script with automatic update checking"

    version_history:
      - version: "1.1"
        date: "2026-01-06"
        changes:
          - "Added example_3: VPS migration v2.0 to v5.1"
          - "Documented complete migration workflow with 10 steps"
          - "Added before/after comparison and statistics"
          - "Added 5 verification tests"
          - "Added next steps for v5.1 features (sparse checkout, auto-update)"

      - version: "1.0"
        date: "2026-01-06"
        changes:
          - "Initial pattern creation"
          - "Documented workflows for submodule, clone, sparse checkout"
          - "Added troubleshooting section with 6 issues"
          - "Added best practices and anti-patterns"
          - "Integrated with AGENT-AUTO-001 bootstrap"
          - "Added success examples 1 and 2"
