# VPS Administration Best Practices
# Recommended patterns for VPS management and optimization

version: "1.0"
category: "vps-best-practices"
last_updated: "2026-01-05"

patterns:
  - id: "VPS-BP-001"
    title: "Layered Monitoring Strategy for VPS"
    severity: "high"
    scope: "vps"

    description: |
      Implement comprehensive monitoring at multiple levels to catch issues
      before they become critical.

    pattern:
      code: |
        # 1. Real-time monitoring (bpytop)
        bpytop

        # 2. Quick status checks
        vps-admin              # Overall system status
        vps-monitor            # Resource monitoring dashboard

        # 3. Log analysis
        sudo nginx-stats       # Quick Nginx analytics
        sudo nginx-analytics   # Full GoAccess analysis

        # 4. Automated daily checks (cron)
        # 0 6 * * * /usr/local/bin/vps-monitor --email-alerts

      explanation: |
        - Real-time: Immediate visual feedback
        - Quick checks: CLI tools for fast diagnosis
        - Log analysis: Identify trends and anomalies
        - Automated: Catch issues without manual intervention

    benefits:
      - "Proactive issue detection"
      - "Historical trend analysis"
      - "Capacity planning"
      - "Performance optimization"

  - id: "VPS-BP-002"
    title: "Incremental Optimization Approach"
    severity: "medium"
    scope: "vps"

    description: |
      Make small, reversible changes and measure impact before proceeding.
      Never optimize blindly without baseline metrics.

    pattern:
      code: |
        # 1. Measure baseline
        vps-monitor > /tmp/before.txt
        free -h >> /tmp/before.txt
        df -h >> /tmp/before.txt

        # 2. Make single change
        sudo systemctl stop fwupd

        # 3. Measure impact
        vps-monitor > /tmp/after.txt
        free -h >> /tmp/after.txt

        # 4. Compare
        diff /tmp/before.txt /tmp/after.txt

        # 5. If improvement: keep
        # If no improvement or worse: revert
        sudo systemctl start fwupd  # revert if needed

      explanation: |
        Making one change at a time allows you to:
        - Attribute improvements to specific changes
        - Revert quickly if something breaks
        - Build confidence in changes
        - Document what works

    anti_patterns:
      - "Stopping multiple services at once"
      - "Restarting server to 'fix' issues"
      - "Applying optimizations without metrics"
      - "Changing everything without baseline"

  - id: "VPS-BP-003"
    title: "Documentation-Driven Administration"
    severity: "high"
    scope: "vps"

    description: |
      Document every change, solution, and procedure. Future you (and AI)
      will thank present you.

    pattern:
      code: |
        # 1. Before making changes, document current state
        vps-admin > /var/log/vps/pre-change-$(date +%F).log

        # 2. Document the change
        cat > /var/log/vps/change-$(date +%F).md << 'EOF'
        # Change: Stop ovpmd service

        ## Date
        2026-01-05

        ## Reason
        Port 8080 conflict with filebrowser container

        ## Commands
        sudo systemctl stop ovpmd
        sudo systemctl disable ovpmd

        ## Results
        - Port 8080 freed
        - Filebrowser container started successfully
        - No impact on VPN services (using X-ray VLESS + Tailscale)

        ## Rollback (if needed)
        sudo systemctl start ovpmd
        EOF

        # 3. Add to knowledge base
        # (If this is a reusable pattern)
        kb.py add vps/errors/networking.yaml

      explanation: |
        Good documentation includes:
        - What you did and why
        - Exact commands used
        - Expected and actual results
        - How to revert the change

    benefits:
      - "Easy troubleshooting"
      - "Knowledge sharing"
      - "Auditable changes"
      - "AI can learn from past solutions"

  - id: "VPS-BP-004"
    title: "Security in Layers (Defense in Depth)"
    severity: "critical"
    scope: "vps"

    description: |
      Never rely on single security measure. Implement multiple layers
      of protection.

    pattern:
      code: |
        # Layer 1: Network level
        # - Block malicious IPs in Nginx
        # - Rate limiting
        sudo tee /etc/nginx/conf.d/security.conf << 'EOF'
        deny 152.32.226.11;
        limit_req_zone $binary_remote_addr zone=one:10m rate=10r/s;
        EOF

        # Layer 2: Application level
        # - Strong authentication
        # - Input validation
        # File Browser config:
        # {
        #   "auth": {
        #     "method": "password",
        #     "password": "strong-random-password"
        #   }
        # }

        # Layer 3: Intrusion detection
        # - Fail2ban for SSH, Nginx
        sudo systemctl enable fail2ban

        # Layer 4: Monitoring
        # - Log monitoring for suspicious activity
        sudo nginx-stats | head -20

        # Layer 5: Backup
        # - Regular backups to offsite location
        sudo vps-backup-simple

      explanation: |
        If one layer fails, others still protect you:
        - Network filtering: Stop obvious attacks
        - App security: Protect if network bypassed
        - Intrusion detection: Catch active attacks
        - Monitoring: Detect what slipped through
        - Backup: Recover if all else fails

    critical_layers:
      - "Firewall/network filtering"
      - "Strong authentication"
      - "Regular updates"
      - "Intrusion detection (Fail2ban)"
      - "Log monitoring"
      - "Offsite backups"
      - "Disaster recovery plan"

  - id: "VPS-BP-005"
    title: "Automated Backup Strategy"
    severity: "critical"
    scope: "vps"

    description: |
      Implement 3-2-1 backup strategy: 3 copies, 2 different types, 1 offsite.

    pattern:
      code: |
        # 1. Daily automated backups (cron)
        # /etc/cron.d/vps-backup
        0 2 * * * root /usr/local/bin/vps-backup-simple >/var/log/vps-backup.log 2>&1

        # 2. Backup critical configs
        # vps-backup-simple.sh includes:
        BACKUP_SOURCES=(
            "/etc/xray"              # VPN configs
            "/usr/local/x-ui"        # X-ui panel
            "/etc/nginx"             # Web server
            "/home/ozand/.claude"    # AI tools
            "/home/ozand/filebrowser" # Services
        )

        # 3. Store offsite via Tailscale
        # Transfer to home server
        rsync -avz /backup ozand@100.82.9.44:/home/ozand/backups/vps/

        # 4. Test backups monthly
        # Restore to test environment
        sudo vps-restore --test

      explanation: |
        3-2-1 Strategy:
        - 3 copies: Local + offsite + rotation
        - 2 types: Configs + full snapshots
        - 1 offsite: Home server via Tailscale

    backup_frequency:
      critical: "Daily (configs, databases)"
      important: "Weekly (application data)"
      archives: "Monthly (long-term retention)"

    testing:
      - "Test restore procedure quarterly"
      - "Document restore steps"
      - "Keep runbook for disaster recovery"

  - id: "VPS-BP-006"
    title: "Service Management with Systemd"
    severity: "medium"
    scope: "vps"

    description: |
      Use systemd for all service management to enable proper lifecycle,
      logging, and dependency management.

    pattern:
      code: |
        # 1. Create systemd service for custom scripts
        sudo tee /etc/systemd/system/vps-monitor.service << 'EOF'
        [Unit]
        Description=VPS Resource Monitor
        After=network.target

        [Service]
        Type=simple
        User=ozand
        ExecStart=/home/ozand/.claude/scripts/vps-monitor.sh --daemon
        Restart=on-failure
        RestartSec=60

        [Install]
        WantedBy=multi-user.target
        EOF

        # 2. Enable and start
        sudo systemctl daemon-reload
        sudo systemctl enable vps-monitor
        sudo systemctl start vps-monitor

        # 3. Check status
        systemctl status vps-monitor

        # 4. View logs
        journalctl -u vps-monitor -f

      explanation: |
        Systemd provides:
        - Automatic restart on failure
        - Centralized logging (journald)
        - Dependency management
        - Consistent interface

    best_practices:
      - "Always set Restart=on-failure for production services"
      - "Use Type=simple for long-running services"
      - "Add After= dependencies if service needs others"
      - "Enable services to survive reboots"
