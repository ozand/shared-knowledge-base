# Clean Architecture Patterns
# Best practices for Clean Architecture implementation in Python

version: "1.0"
category: "architecture-patterns"
last_updated: "2026-01-04"

principles:
  dependency_rule:
    description: "Dependencies point inward. Inner layers know nothing of outer layers."
    rule: "Domain → Application → Infrastructure → Interfaces"

    good_example: |
      # Domain entity (no dependencies)
      @dataclass
      class TrafficRecord:
          domain: str
          visits: int

      # Application service (depends on domain)
      class ProcessingService:
          def __init__(self, repository: TrafficRecordRepository):
              self._repository = repository  # Interface from domain

      # Infrastructure (implements domain interface)
      class TrafficRecordRepositoryImpl(TrafficRecordRepository):
          def save(self, record: TrafficRecord) -> None:
              # Implementation details

    bad_example: |
      # Domain depending on infrastructure - WRONG!
      from src.infrastructure.database import PostgresConnection

      class TrafficRecord:
          def save(self):
              db = PostgresConnection()  # Domain knows about Postgres!

  dependency_inversion:
    description: "Depend on abstractions, not concretions"

    pattern: |
      # Domain layer defines interface
      from abc import ABC, abstractmethod

      class TrafficRecordRepository(ABC):
          @abstractmethod
          def save(self, record: TrafficRecord) -> None:
              pass

      # Infrastructure implements interface
      class PostgresTrafficRecordRepository(TrafficRecordRepository):
          def save(self, record: TrafficRecord) -> None:
              # Postgres-specific implementation

layers:
  domain:
    location: "src/domain/"
    purpose: "Business logic, entities, and core abstractions"
    dependencies: "None (innermost layer)"

    contains:
      - "Entities (BaseEntity, TrafficRecord, FileMetadata)"
      - "Value Objects (ProgressStatus, FileSizeCategory)"
      - "Repository Interfaces (abstract base classes)"
      - "Domain Services (pure business logic)"
      - "Domain Events"

    rules:
      - "No dependencies on outer layers"
      - "No framework dependencies (FastAPI, SQLAlchemy, etc.)"
      - "Pure Python with only stdlib imports"
      - "All logic is testable without infrastructure"

    example: |
      # src/domain/entities/traffic_record.py
      from dataclasses import dataclass
      from datetime import datetime

      @dataclass
      class TrafficRecord:
          """Domain entity representing traffic data."""
          domain: str
          visits: int
          date: datetime

          def is_valid(self) -> bool:
              """Business rule: validate record."""
              return len(self.domain) > 0 and self.visits >= 0

  application:
    location: "src/application/"
    purpose: "Use cases and application services"
    dependencies: "Domain only"

    contains:
      - "Use Case implementations"
      - "Application Services"
      - "DTOs (Data Transfer Objects)"
      - "Application-level validation"
      - "Workflow orchestration"

    rules:
      - "Depends only on domain layer"
      - "No infrastructure dependencies"
      - "Orchestrates domain objects"
      - "Implements use cases"

    example: |
      # src/application/services/file_processing_service.py
      from src.domain.repositories import TrafficRecordRepository
      from src.domain.entities import TrafficRecord

      class FileProcessingService:
          """Application service for file processing use case."""

          def __init__(self, repository: TrafficRecordRepository):
              self._repository = repository  # Depends on domain interface

          def process_file(self, file_path: str) -> ProcessingResult:
              """Use case: process file and save records."""
              records = self._parse_file(file_path)
              for record in records:
                  self._repository.save(record)
              return ProcessingResult(...)

  infrastructure:
    location: "src/infrastructure/"
    purpose: "Technical implementations and external integrations"
    dependencies: "Domain, Application"

    contains:
      - "Repository implementations"
      - "File readers/writers"
      - "Database access (SQLAlchemy)"
      - "External API clients"
      - "Caching, logging, monitoring"

    rules:
      - "Implements domain interfaces"
      - "Contains all framework code"
      - "Handles technical details"
      - "No business logic"

    example: |
      # src/infrastructure/repositories/traffic_record_repository_impl.py
      from sqlalchemy.orm import Session
      from src.domain.repositories import TrafficRecordRepository
      from src.domain.entities import TrafficRecord

      class TrafficRecordRepositoryImpl(TrafficRecordRepository):
          """Postgres implementation of repository."""

          def __init__(self, session: Session):
              self._session = session

          def save(self, record: TrafficRecord) -> None:
              """Save record to Postgres."""
              db_record = TrafficRecordModel.from_entity(record)
              self._session.add(db_record)
              self._session.commit()

  interfaces:
    location: "src/interfaces/"
    purpose: "Entry points and adapters"
    dependencies: "Application, Infrastructure"

    contains:
      - "REST API endpoints (FastAPI)"
      - "CLI commands"
      - "WebSocket handlers"
      - "API request/response models"

    rules:
      - "Adapts external requests to application layer"
      - "Depends on application services"
      - "Handles HTTP, CLI, etc."
      - "No business logic"

    example: |
      # src/interfaces/api/routes/files.py
      from fastapi import APIRouter, Depends
      from src.application.services import FileProcessingService

      router = APIRouter()

      @router.post("/files/process")
      async def process_file(
          request: ProcessFileRequest,
          service: FileProcessingService = Depends(get_service)
      ):
          """API endpoint adapts HTTP to application service."""
          result = service.process_file(request.file_path)
          return ProcessFileResponse.from_result(result)

patterns:
  factory_pattern:
    use_case: "Create complex objects with dependencies"

    example: |
      # src/infrastructure/file_processing/factory.py
      class FileProcessorFactory:
          """Factory for creating file processors."""

          def create_reader(self, file_format: str) -> FileReader:
              if file_format == "csv":
                  return CSVReader()
              elif file_format == "json":
                  return JSONReader()
              elif file_format == "jsonl":
                  return JSONLReader()
              else:
                  raise ValueError(f"Unsupported format: {file_format}")

    benefits:
      - "Encapsulates object creation logic"
      - "Easy to add new formats"
      - "Single place to modify creation logic"

  repository_pattern:
    use_case: "Abstract data access from business logic"

    pattern: |
      # Domain defines interface
      class Repository(ABC):
          @abstractmethod
          def get_by_id(self, id: str) -> Entity | None:
              pass

          @abstractmethod
          def save(self, entity: Entity) -> None:
              pass

      # Infrastructure implements
      class PostgresRepository(Repository):
          def get_by_id(self, id: str) -> Entity | None:
              return self._session.query(Model).filter_by(id=id).first()

  service_pattern:
    use_case: "Encapsulate business operations"

    example: |
      # src/application/services/validation_service.py
      class ValidationService:
          """Application service for validation use case."""

          def __init__(self, rules: List[ValidationRule]):
              self._rules = rules

          def validate(self, data: dict) -> ValidationResult:
              errors = []
              for rule in self._rules:
                  if not rule.check(data):
                      errors.append(rule.error_message)
              return ValidationResult(is_valid=len(errors) == 0, errors=errors)

  dependency_injection:
    use_case: "Inject dependencies instead of creating them"

    good_example: |
      class FileProcessor:
          def __init__(
              self,
              reader: FileReader,
              validator: Validator,
              repository: Repository
          ):
              """Dependencies injected via constructor."""
              self._reader = reader
              self._validator = validator
              self._repository = repository

    bad_example: |
      class FileProcessor:
          def __init__(self):
              # Creating dependencies - tight coupling!
              self._reader = CSVReader()
              self._validator = SchemaValidator()
              self._repository = PostgresRepository()

best_practices:
  code_organization:
    - "One class per file"
    - "Group related files in modules"
    - "Use __init__.py to expose public API"
    - "Keep files under 500 lines"

  naming_conventions:
    - "Entities: nouns (TrafficRecord, User)"
    - "Services: <Domain>Service (FileProcessingService)"
    - "Repositories: <Entity>Repository (TrafficRecordRepository)"
    - "Use cases: verb phrases (ProcessFile, ValidateData)"

  type_hints:
    - "Use type hints everywhere"
    - "Use | None instead of Optional (Python 3.10+)"
    - "Use Protocol for interfaces"
    - "Use dataclasses for entities"

  testing:
    - "Test domain logic without infrastructure"
